function tri_norm=reo(PTS,m,n)
%makes an "order array" based on a surface harmonic model containing M tiers of N lines each
%(a highly customized function depending on the particular output from SurfHarmMod)
%the order array is the order to output the individual points in order to make a triangular mesh of the surface
%seems to work, 20070111pmc
%also do triangle and normal output for POVRAY..
%works! (no difference between earlier by-hand matrix and one generated by this program, 20070112pmc)

e=0;
for i = 1:2:(2*n-3)
    e=e+1;
    a(e,1:3)=[i,i+3,i+1];
    end
for b = ((2*n)+1:2*n:2*n*(m-1)) %loop over tiers
    for i=(b:b+(2*n-3)) %loop over points within a tier
        e=e+1;
        if mod(e,2), a(e,1:3)=[i,i+2,i+1]; end 
        if mod(e+1,2), a(e,1:3)=[i,i+1,i+2]; end 
        end
    end
for i = (((m-1)*2*n)+1:2:(2*m*n)-3)
    e=e+1;
    a(e,1:3)=[i,i+2,i+1];
    end

a=a';a=a(:)';a=PTS(a,:);    %populate 'a' with actual points

la=length(a);

for j=0:(e-1);
    r=a(((3*j)+1):((3*j)+3),1:3);
    a(((3*j)+1):((3*j)+3),4:6)=repmat(cross(r(3,:)-r(1,:),r(2,:)-r(1,:)),[3 1]);
    end
a(:,4:6)./=repmat(sqrt(sum(a(:,4:6)'.^2))',[1 3]);%normalize all normals
%now have triangles and normalized normals, and need to average normals around every point....
tri_norm=[a(:,1:3) zeros(la,3)]; 
for j=1:la;
    q=sum((repmat(a(j,1:3),[la 1])==a(:,1:3))')';
    qf=find(q==3); %all indexes of the same point
    tri_norm(qf,4:6)+=repmat(a(j,4:6),[length(qf) 1]);
    end

tri_norm(:,4:6)./=repmat(sqrt(sum(tri_norm(:,4:6)'.^2)'),[1 3]); %final normalization of normals
%final output is: 3Nx6 matrix, where N triangles are in the first 3 columns, and normals at each triangle point are in the last 3 columns.
